/* ---------------------------------
createBookmark
--------------------------------- */

import { call, put, select, takeEvery } from "redux-saga/effects";
import {
  createBookmark,
  createBookmarkError,
  createBookmarkPending,
  createBookmarkSuccess,
  showNotif,
} from "../store/actions";
import { db } from "../mocks";
import { IInitialState } from "../types/initial-state";
import {
  TagType,
  TBookmarkInDB,
  TTagBundle,
  TTagInDB,
  TTagsInDB,
} from "../types/bookman";

function* createBookmarkSaga(action) {
  const { payload: bookmark } = action;

  const authSelector = (state: IInitialState) => state.authentication;

  const {
    user: { uid },
  } = yield select(authSelector);

  /**
   * detectPreexistingTags
   */

  function detectPreexistingTags(
    existingTags: TTagsInDB,
    candidateTag: TagType
  ): TTagInDB | undefined {
    return Object.values(existingTags).find(
      tag => tag.value === candidateTag.value
    );
  }

  yield put(createBookmarkPending());

  try {
    const context = db.ref();
    const newBookmarkRef = db.ref("/bookmarks").push().key;
    const tagRefs = [];

    if (!newBookmarkRef) {
      throw new Error("Missing FireBase key!");
    }

    let tagUpdates = {};

    /**
     * process this part only if tags are present
     */

    if (bookmark.tags.length) {
      const tagsRef = db.ref(`/tags`).orderByChild("createdBy").equalTo(uid);
      const tagsSnap = yield tagsRef.once("value");
      const tagValues = tagsSnap.val();

      // we build the update payload for the tags part…
      tagUpdates = (bookmark.tags as TTagBundle).reduce((acc, tag) => {
        const preExistingTag = detectPreexistingTags(tagValues, tag);

        // if the tag already exists in DB,
        // based on value
        if (preExistingTag) {
          tagRefs.push(preExistingTag._key);

          // we write a new ref for this bookmark
          // into the existing tag's 'bookmarks'
          acc[`/tags/${preExistingTag._key}/bookmarks`] = {
            ...preExistingTag.bookmarks,
            [newBookmarkRef]: true,
          };
        }

        // if, instead, it's a new tag
        else {
          const newTagRef = db.ref("/tags").push().key;

          if (!newTagRef) {
            throw new Error("Missing FireBase key!");
          }

          tagRefs.push(newTagRef);

          acc[`/users/${uid}/tags/${newTagRef}`] = true;
          acc[`/tags/${newTagRef}`] = {
            ...tag,
            _key: newTagRef,
            bookmarks: { [newBookmarkRef]: true },
            createdBy: uid,
          } as TTagInDB;
        }

        return acc;
      }, {});
    }

    // …then for the bookmark part
    const bookmarkUpdates = {
      [`/users/${uid}/bookmarks/${newBookmarkRef}`]: true,
      [`/bookmarks/${newBookmarkRef}`]: {
        ...bookmark,
        _key: newBookmarkRef,
        createdBy: uid,
        // we override tags
        tags: tagRefs.length
          ? tagRefs.reduce((acc, ref) => {
              acc[ref] = true;

              return acc;
            }, {})
          : [],
        // optional loose tagRefs just in case
        ...(tagRefs.length ? { tagKeys: tagRefs } : {}),
      } as TBookmarkInDB,
    };

    // we create the bookmark remotely
    yield call(
      {
        context,
        fn: context.update,
      },

      {
        ...bookmarkUpdates,
        ...tagUpdates,
      }
    );

    // this is the key generated by firebase
    yield put(
      createBookmarkSuccess({ remoteKey: newBookmarkRef, ...bookmark })
    );

    yield put(
      showNotif({
        message: `Created new bookmark!`,
        icon: "star",
        timeout: 2000,
        theme: "light",
      })
    );

    //
  } catch (error) {
    //
    console.error(error);
    yield put(createBookmarkError({ error }));
  }
}

/**
 * createBookmark
 */

export default function* () {
  yield takeEvery(`${createBookmark}`, createBookmarkSaga);
}
